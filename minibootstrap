#!/bin/bash

set -e

function err() {
    echo $1 >&2
}

function log() {
    echo "[+] $1"
}

function panic() {
    err "[!] $1"
    exit 1
}

# fetch("https://www.example.com/foo/bar.tar", "/tmp") -> "/tmp/www.example.com/foo/bar.tar"
function fetch() {
    local url=$1
    local destination=$2
    local localpath="$destination/$(strip_scheme $url)"

    mkdir -p $(dirname $localpath)

    if ! curl --no-progress-meter --fail --location --output $localpath $url
    then
        panic "Error while fetching $1"
    fi

    echo $localpath
}

function extname() {
    local path=$1
    local file=$(basename $path)
    echo "${file##*.}"
}

function remove_ext() {
    local path=$1
    local ext=".$(extname $path)"

    echo "$(dirname $path)/$(basename $path $ext)"
}

function ensure_command() {
    local cmd=$1
    local message=$2
    if ! which "$cmd" > /dev/null
    then
        panic $message
    fi
}

function ensure_file() {
    local file=$1

    if [ ! -f "$file" ]
    then
        panic "Couldn't find file: $file"
    fi
}

function decompress() {
    local path=$1
    local file=$(basename $path)
    local extension

    case $(extname $path) in
    zst)
        ensure_command unzstd "Missing unzstd. Try: brew install zstd"
        unzstd --quiet $path
        ;;
    bz2)
        bunzip2 --quiet $path
        ;;
    xz)
        unxz --quiet $path
        ;;
    gz)
        gunzip --quiet $path
        ;;
    *)
        panic "Unknown compression format $path"
        ;;
    esac
}

function extract_deb() {
    local deb=$1
    local destination=$2
    local name=$(basename $deb)
    local dir="$(dirname $deb)/$(basename $deb .deb)"

    mkdir -p $dir

    pushd $dir >/dev/null

    ar -x "../$name"
    local datafile=$(ls data.tar.* | head -n1)

    if [ "$datafile" = "" ] || [ ! -f "$datafile" ]
    then
        panic "Can't find data.tar in $deb"
    fi

    decompress $datafile
    tar -xf data.tar -C $destination

    popd >/dev/null
}

function strip_scheme() {
    local url=$1

    echo $(echo $url | sed -E 's@^https?://@@')
}

# Debian signing keys (for later): https://ftp-master.debian.org/keys.html

function fetch_ubuntu_archive_signing_key() {
    local version=$1
    local destination=$2
    local url key_path

    case $version in
    jammy)
        url="https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/ubuntu-keyring/2021.03.26/ubuntu-keyring_2021.03.26.tar.gz"
        key_path="ubuntu-keyring-2021.03.26/keyrings/ubuntu-keyring-2018-archive.gpg"
        ;;
    *)
        panic "Unknown Ubuntu version: $version"
        ;;
    esac

    log "Fetching $url"
    local archive_path=$(fetch $url $destination)

    local depth=$(echo $key_path | awk -F/ '{print NF-1}')

    tar -xzf $archive_path --directory $destination --strip-components $depth $key_path
}

function ubuntu_mirror() {
    local arch=$1

    if [ "$arch" = "amd64" ] || [ "$arch" = "i386" ]
    then
        echo http://archive.ubuntu.com/ubuntu
    else
        echo http://ports.ubuntu.com/ubuntu-ports
    fi
}

function verify_sig() {
    local file=$1
    local signature=$2
    local keyring=$3

    if ! gpgv --keyring $keyring $signature $file 2> /dev/null
    then
        panic "Unable to verify $(basename $file)"
    fi
}

function verify_sha256() {
    local file=$1
    local expected=$2

    local actual=$(shasum -a 256 $file | awk '{ print $1 }')
    if [ "$actual" = "" ]; then
        panic "Unable to compute SHA256 sum for $file"
    fi

    if [ ! "$actual" = "$expected" ]; then
        panic "Unexpected SHA256 sum for $(basename $file). Expected $expected, but got $actual."
    fi
}

function release_read_sha256() {
    local release=$1
    local dist_path=$2

    local shastart=$(grep --line-number --max-count=1 ^SHA256: $1 | cut -d: -f1)
    if [ "$shastart" = "" ]; then
        return
    fi

    local expected=$(tail -n +$shastart $release | grep --max-count=1 $dist_path | awk '{ print $1 }')
    if [ "$expected" = "" ]; then
        return
    fi

    echo $expected
}

if [ $# -lt 4 ]
then
    err "usage: $0 version arch sysroot package ..."
    exit 1
fi

version=$1
arch=$2
relroot=$3

shift 3

mirror=$(ubuntu_mirror $arch)

tmpdir=$(mktemp -d)

mkdir -p $relroot
sysroot=$(readlink -f $relroot)

fetch_ubuntu_archive_signing_key $version $tmpdir
archive_key=$(ls $tmpdir/*.gpg | head -n1)
ensure_file $archive_key

log "Found archive signing key: $(basename $archive_key)"

# TODO: Change this to InRelease which includes both the signature and the data

dist="$mirror/dists/$version"

release_url="$dist/Release"
release_gpg_url="$dist/Release.gpg"

log "Fetching $release_url"
release=$(fetch $release_url $tmpdir)

log "Fetching $release_gpg_url"
release_gpg=$(fetch $release_gpg_url $tmpdir)

log "Verifying Release"

verify_sig $release $release_gpg $archive_key

packages_repo_path="main/binary-$arch/Packages"
packages_gz_url="$dist/main/binary-$arch/Packages.gz"

log "Fetching $packages_gz_url"
packages_gz=$(fetch $packages_gz_url $tmpdir)
packages=$(remove_ext $packages_gz)

gunzip $packages_gz

log "Verifying Packages"

expected=$(release_read_sha256 $release $packages_repo_path)
if [ "$expected" = "" ]; then
    panic "Unable to read SHA256 of $packages_path from $release"
fi

verify_sha256 $packages $expected

paths=()
shasums=()

while [ $# -gt 0 ]
do
    package=$1
    shift

    if ! line=$(grep -n "Package: $package" $packages)
    then
        panic "Unable to locate package $package"
    fi

    offset=$(echo $line | cut -d: -f1)
    repo_path=$(tail -n +$offset $packages | grep --max-count=1 "Filename: " | awk -F": " '{ print $2 }')
    shasum=$(tail -n +$offset $packages | grep --max-count=1 "SHA256: " | awk -F": " '{ print $2 }')

    if [ "$repo_path" = "" ]
    then
        panic "Unable to find repo path for $package. This shouldn't happen."
    fi

    url="$mirror/$repo_path"

    log "Fetching $url"
    path=$(fetch $url $tmpdir)

    paths+=($path)
    shasums+=("$shasum")
done

for index in ${!paths[@]}
do
    path=${paths[$index]}
    expected=${shasums[$index]}
    filename=$(basename $path)

    log "Verifying $filename"
    verify_sha256 $path $expected

    log "Extracting $filename"
    extract_deb $path $sysroot
done

log "Fixing symlinks..."

pushd $sysroot > /dev/null

for link in $(find . -type l -lname '/*')
do
    dir=$(dirname $link)
    absolute_target=$(readlink $link)
    prefix=$(dirname "$dir" | sed 's@[^/]*@\.\.@g')
    relative_target="$prefix$absolute_target"

    ln -snf $relative_target $link
done

popd > /dev/null

rm -rf $tmpdir
